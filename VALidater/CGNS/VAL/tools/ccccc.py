#!/usr/bin/env python
#  -------------------------------------------------------------------------
#  pyCGNS.VAL - Python package for CFD General Notation System - VALidater
#  See license.txt file in the root directory of this Python module source  
#  -------------------------------------------------------------------------
#  $Release$
#  -------------------------------------------------------------------------
#
import CCCCC.parser.parse     as cps
import CCCCC.parser.match     as cpm
import CCCCC.utils.exceptions as ex
import CCCCC.utils.filepaths
import CCCCC.utils.stuff      as ustf
#import CCCCC.utils.rng_val    as rng
import CCCCC.tools.rnc2rng.rt as trang  # Trang Java external tool
import xml.dom.minidom as XmlDom
import libxml2
import libxslt
import sys
import os
import getopt
import tempfile
import string

goreturnstatus=0

ARG="bz"
class ErrorHandler:

    def __init__(self):
        self.errors = []

    def handler(self, msg, data):
        e = libxml2.lastError()
        print e.file()
        print e.line()
        if data != ARG:
            raise Exception, "Error handler did not receive correct argument"
        self.errors.append(msg)

def cgnsParseError(localcontext,unused):
  e = libxml2.lastError()
  lfs=""
  if e.file():
    tf=open(e.file())
    ltf=tf.readlines()
    tf.close()
    lfs=ltf[e.line()-1]
    
  _diag=["Info","Warning","Severe","Fatal"]
  ustf.error(99,"[%s] near line %d in %s\nPhase: %s\nDiagnostic:\n%s\n"\
        %(_diag[e.level()],e.line(),e.file(),localcontext,e.message()),kill=0)
  if lfs: print lfs
  if (e.level() > 1):
    ustf.c5exit() # fails with None return (loop ?)

# ------------------------------------------------------------
def p_syntax(schemafile,file,ofile):
  if (not schemafile):
    schema_name=CCCCC.utils.filepaths.CCCCC_topfile
    stag="SIDS"
  else:
    schema_name=schemafile
    stag="USER"

  inputs = open(schema_name, 'r')
  schema = inputs.read()
  inputs.close()
  ustf.ttt("p_syntax schema [%s]"%schema_name)

  inputd = open(file, 'r')
  data = inputd.read()
  inputd.close()

  libxml2.registerErrorHandler(cgnsParseError,"%s Schema Syntax"%schema_name)
  rngp = libxml2.relaxNGNewMemParserCtxt(schema, len(schema))
  #libxml2mod.xmlRelaxNGSetParserErrors(rnpg,callback,callback,'Zap')
  try:
      rngs = rngp.relaxNGParse()
  except libxml2.parserError:
    global goretrunstatus
    goreturnstatus=-1
    ustf.error(30,"Syntax pass FAILS (Cannot use %s as relaxNG specification)"%schema_name)

  ctxt = rngs.relaxNGNewValidCtxt()
  doc  = libxml2.parseDoc(data)
  e = ErrorHandler()
  ctxt.setValidityErrorHandler(e.handler,e.handler,ARG)
  ret  = doc.relaxNGValidateDoc(ctxt)
  if (ret != 0):
    global goretrunstatus
    goreturnstatus=-1
    ustf.pstack(e.errors)
    ustf.error(31,"Syntax pass FAILS (during RelaxNG validation [%d])"%ret)
  else:
    ustf.message("OK - %s Syntax pass"%stag)

  doc.freeDoc()

  del rngp
  del rngs
  del ctxt

  #r = p_syntaxRestric(schema_name,file)   
  #return r

  return ""

# ------------------------------------------------------------
def p_syntaxRestric(schemafile,file):

  libxml2.registerErrorHandler(cgnsParseError,"%s Schema Syntax"%schemafile)

  sch_extract = CCCCC.utils.filepaths.CCCCC_extractfilesch
  my_rng = schemafile
  # If we can see the schematron extrated from the rng file
   
  ustf.ttt("rng file ->%s"%my_rng)
  ustf.ttt("extract schematron file ->%s"%sch_extract)

  #1-1 sch_extract_xslt : this is a libxml2 document tree obtained by parsing
  #the XML file "sch_extract" containing the stylesheet.
  ustf.ttt("parse stylesheet file [%s]"%sch_extract)
  sch_extract_xslt  = libxml2.parseFile(sch_extract)
     
  #1-2 sch_extract_style : this is a precompiled stylesheet ready
  #to be used by the following transformations
  ustf.ttt("check stylesheet file [%s]"%sch_extract)
  sch_extract_style = libxslt.parseStylesheetDoc(sch_extract_xslt)
     
  #1-3 my_rng_xslt : this is the document (schematron rules)
  #to apply the transformation to
  ustf.ttt("parse rng file [%s]"%my_rng)
  my_rng_xslt    = libxml2.parseFile(my_rng)

  #1-4 my_schematron = this is the document generated by applying
  #the stylesheet (sch_extract_style) to the document (my_rng_xslt)
  ustf.ttt("extract schematron schema from rng file [%s] by applying the stylesheet [%s]"%(my_rng,sch_extract))
  try:
    my_schematron = sch_extract_style.applyStylesheet(my_rng_xslt, None)
  except:
    global goretrunstatus
    goreturnstatus=-1
    ustf.error(20,"Syntax Pass step 2 FAILS (rng file contains an error)")

  #sch_extract_style.saveResultToFilename(result_sch, my_schematron, 0)   
       
  #1-6 deallocation documents with freeDoc() except for the stylesheet document
  #which is freed when its compiled form is garbage collected.
  sch_extract_style.freeStylesheet()
  my_rng_xslt.freeDoc()

  # --- processing step 2
  sch_basic=CCCCC.utils.filepaths.CCCCC_topfilexsl
  #validate_xsl   = "%s.xsl"%tempfile.mktemp()  #temporary file to store validate file xslt
  
  ustf.ttt("schematron file xsl ->%s"%sch_basic)
  ustf.ttt("parse stylesheet file [%s]"%sch_basic)
  sch_basic_xslt  = libxml2.parseFile(sch_basic)
     
  ustf.ttt("check stylesheet file [%s]"%sch_basic)
  sch_basic_style = libxslt.parseStylesheetDoc(sch_basic_xslt)
     
  ustf.ttt("generate validate file by applying the stylesheet [%s] on the schematron file [%s]"%(sch_basic,my_schematron))
  try:
      validate_xslt    = sch_basic_style.applyStylesheet(my_schematron, None)
  except:
      ustf.error(21,"Syntax pass step 2 FAILS (Schematron file contains an error)")
       
  #sch_basic_style.saveResultToFilename(validate_xsl, validate_xslt, 0)
     
  sch_basic_style.freeStylesheet()
  my_schematron.freeDoc()
     
  # --- processing step 3
  my_xml = file
  
  ustf.ttt("Parse xml file [%s]"%my_xml)
  try:
    my_xml_xslt = libxml2.parseFile(my_xml)
  except:
    global goretrunstatus
    goreturnstatus=-1
    ustf.error(22,"Syntax pass step 2 FAILS (xml file [%s] contains errors)"%my_xml)

  validate_style = libxslt.parseStylesheetDoc(validate_xslt)
  
  try:
    result = validate_style.applyStylesheet(my_xml_xslt, None)
  except:
    global goretrunstatus
    goreturnstatus=-1
    ustf.error(23,"Syntax pass step 2 FAILS (Validate xsl file contains an error)")
    
  try:
    r = validate_style.saveResultToString(result)
    global goretrunstatus
    goreturnstatus=-1
    ustf.error(24,"Syntax pass step 2 FAILS")
  except SystemError:
    # it looks that in libxslt-1.1.2/python/libxslt.c:530
    # a NULL result couldn't appear. It looks also that in
    # the case we have no errors, ouput is empty !
    r=""
    ustf.message("Syntax pass step 2 OK")
    
  validate_style.freeStylesheet()
  my_xml_xslt.freeDoc()
  result.freeDoc()
  
  return r
# ------------------------------------------------------------
def p_semantics(schemafile,file):

  libxml2.registerErrorHandler(cgnsParseError,"%s Schema Semantics"%schemafile)

  # may be overwritten below
  output_xslt    =CCCCC.utils.filepaths.CCCCC_topfilexslt
  schematron_xslt=CCCCC.utils.filepaths.CCCCC_topfilexsl
  my_schematron  =CCCCC.utils.filepaths.CCCCC_topfiletron

  ustf.ttt("schematron xsl top file ->%s"%schematron_xslt)
  ustf.ttt("schematron default file ->%s"%my_schematron)
  ustf.ttt("output xslt file ->%s"%output_xslt)

  # ---------------------------------------------------------------------
  if (schemafile):
      output_xslt="%s.xsl"%tempfile.mktemp() 
      my_schematron=schemafile
      stag="USER"
  else:
      ustf.ttt("using default schematron rules ->%s"%my_schematron)
      stag="SIDS"

  # ---------------------------------------------------------------------
  ustf.ttt("schematron file ->%s"%my_schematron)
  ustf.ttt("temporary xsl file ->%s"%output_xslt)

  # --- processing step 1
  #1-1 schematron : this is a libxml2 document tree obtained by parsing
  #the XML file "schematron_xslt (cgns.xslt)" containing the stylesheet.
  ustf.ttt("parse stylesheet file [%s]"%schematron_xslt)
  schematron  = libxml2.parseFile(schematron_xslt)
  
  #1-2 schemastyle : this is a precompiled stylesheet ready
  #to be used by the following transformations
  ustf.ttt("check stylesheet file [%s]"%schematron_xslt)
  schemastyle = libxslt.parseStylesheetDoc(schematron)
  
  #1-3 my_rules : this is the document (schematron rules)
  #to apply the transformation to
  ustf.ttt("parse schematron file [%s]"%my_schematron)
  my_rules    = libxml2.parseFile(my_schematron)

  #1-4 cgnsstyle = this is the document generated by applying
  #the stylesheet (schemastyle) to the document (my_rules)
  ustf.ttt("generate file by applying the stylesheet [%s] on the schematron file [%s]"%(schematron_xslt,my_schematron))
  try:
   cgnsstyle = schemastyle.applyStylesheet(my_rules, None)
  except:
   global goretrunstatus
   goreturnstatus=-1
   ustf.error(41,"%s Semantic pass FAILS (Schematron file contains an error)"%stag)
    
  #1-5 result of the generation is saved in a file (output_xslt)  
  schemastyle.saveResultToFilename(output_xslt, cgnsstyle, 0)

  #1-6 deallocation documents with freeDoc()
  # except for the stylesheet document
  #which is freed when its compiled form is garbage collected.
  schemastyle.freeStylesheet()
  my_rules.freeDoc()
  cgnsstyle.freeDoc()
     
  # ---------------------------------------------------------------------
  # --- processing step 2
  target_xml   = file
  
  #2-1 cgnsstylef : this is a libxml2 document tree obtained by parsing
  #the XML file "output_xslt (cgns.xslt or temp file)"
  #containing the stylesheet.
  try:
    cgnsstylef = libxml2.parseFile(output_xslt)        
  except:
    global goretrunstatus
    goreturnstatus=-1
    ustf.error(42,"%s Semantic pass FAILS (xslt file [%s] contains errors)"%(stag,output_xslt))

  #2-2 cgnsstylet : This is a precompiled stylesheet ready
  #to be used by the following transformations
  cgnsstylet   = libxslt.parseStylesheetDoc(cgnsstylef)

  #2-3 target : this is the document (xml file)
  #to apply the transformation to
  try:
    target     = libxml2.parseFile(target_xml)
  except:
    global goretrunstatus
    goreturnstatus=-1
    ustf.error(43,"%s Semantic pass FAILS (xml file [%s] contains errors)"%(stag,target_xml))

  #2-4 result = this is the document generated by applying
  #the stylesheet (cgnsstylet) to the document (target)
  try:
    result     = cgnsstylet.applyStylesheet(target, None)
  except:
    global goretrunstatus
    goreturnstatus=-1
    ustf.error(44,"%s Semantic pass FAILS (Schematron xsl file contains an error)"%stag)
  expectedEmptyResult="""<?xml version="1.0"?>\n"""
  #2-5 result of the generation is saved in a string 'r'
  if (result and (str(result) == expectedEmptyResult)):
      ustf.message("OK - %s Semantic pass"%stag)
      resultP=""
  else:
      global goretrunstatus
      goreturnstatus=-1
      resultP= cgnsstylet.saveResultToString(result)
      ustf.message("%s Semantic pass diagnostics:\n%s"%(stag,resultP))
      ustf.error(45,"%s Semantic pass FAILS"%stag)

  # *** should de-allocate here ***
  #2-6 deallocation documents with freeDoc() except for the stylesheet document
  #which is freed when its compiled form is garbage collected.
  cgnsstylet.freeStylesheet()
  result.freeDoc()
  target.freeDoc()
  
  return resultP

# ------------------------------------------------------------
def p_generateXML(infile,outfile,fl,dt,arsz):
  outputfile=open(outfile,'w+')
  if (fl): fl=cps.mFOLLOW
  else:    fl=cps.mNOFOLLOW
  if (dt): dt=cps.mLARGE
  else:    dt=cps.mNOLARGE
  r=cps.ParseTree([cps.mCGNSXML,dt,fl],outputfile,arraySize=arsz)
  plist=r.parse(infile)
  for s in plist:
    outputfile.write(s)
    outputfile.write('\012')
  outputfile.close()

# ------------------------------------------------------------
def p_generateHDF(infile,outfile,fl,gpy):
  otmp=string.replace(outfile,"/","_")
  otmp=string.replace(otmp,".","_")
  oname=otmp+".py"
  outputfile=open(oname,'w+')
  ustf.ttt("generating file ->%s"%otmp)
  xml_dom_object = XmlDom.parse(infile)
  t=cpm.TreeGenerator(xml_dom_object,outputfile,1,outfile)
  t.generate()
  #reader.releaseNode(xml_dom_object)
  outputfile.write('\012')
  outputfile.close()
  ustf.ttt("interpreting file ->%s"%otmp+".py")
  try:
    import imp
    m=imp.find_module(otmp,["./"])
    imp.load_module(otmp,m[0],m[1],m[2])
  except ValueError:
    ustf.error(50,
               "Problem while CGNS binary file generation, check [%s])"%oname)
    ustf.c5exit()
  if (not gpy): os.remove(oname)
  else:         ustf.message("OK - pyCGNS file is %s"%oname)
  os.remove(otmp+".pyc")
  
# ------------------------------------------------------------
def p_preprocessor(xslfile,infile,outfile):

  pp_xslt=CCCCC.utils.filepaths.CCCCC_ppfile

  libxml2.registerErrorHandler(cgnsParseError,"Pre-processing")

  ustf.ttt("xsl preprocessor file ->%s"%pp_xslt)

  stag="SIDS"
  if (xslfile):
    pp_xslt=xslfile
    stag="USER"

  target_xml  = infile
  ustf.ttt("parse target file [%s]"%target_xml)
  try:
    target      = libxml2.parseFile(target_xml)
  except libxml2.parserError:
    global goretrunstatus
    goreturnstatus=-1
    ustf.error(34,"Preprocessing pass FAILS (Cannot parse %s as xml)"%target_xml)

  ustf.ttt("parse preprocessor file [%s]"%pp_xslt)
  try:
    cgnsstylef  = libxml2.parseFile(pp_xslt)
  except libxml2.parserError:
    global goretrunstatus
    goreturnstatus=-1
    ustf.error(32,"Preprocessing pass FAILS (Cannot parse %s as xslt)"%pp_xslt)
    
  ustf.ttt("check preprocessor file [%s]"%pp_xslt)
  cgnsstylet  = libxslt.parseStylesheetDoc(cgnsstylef)
  ustf.ttt("check target file [%s]"%target_xml)
  if (not cgnsstylet):
    global goretrunstatus
    goreturnstatus=-1
    ustf.error(33,"Preprocessing pass FAILS (Cannot use %s as xslt)"%pp_xslt)
  result      = cgnsstylet.applyStylesheet(target, None)

  ustf.ttt("save result file [%s]"%outfile)
  r=cgnsstylet.saveResultToFilename(outfile,result,0)

  ustf.message("OK - %s Preprocessing pass"%stag)

  return r

# ------------------------------------------------------------
def readTagDir(tag,cpass):
  r="%s/%s"%(CCCCC.utils.filepaths.CCCCC_topuserdirP,tag)
  if (not os.path.isdir(r)):
    ustf.error(80,"No such directory: %s"%r)
  if (cpass == 0): # preprocessing
    d="%s/%s"%(r,"c5preprocessing.xsl")  
    if (os.path.isfile(d)): return d
    return None
  if (cpass == 1): # syntax
    d="%s/%s"%(r,"c5syntax.rng")  # rng only !
    if (os.path.isfile(d)): return d
    return None
  if (cpass == 2): # semantic
    d="%s/%s"%(r,"c5semantic.sch")  
    if (os.path.isfile(d)): return d
    return None

# ------------------------------------------------------------
def testFile(filename,shouldbethere=0):
   import os.path
   import sys
   if (os.path.isfile(filename)):
      if (not shouldbethere):
        ustf.error(1,"file %s already exists"%filename)
   else:
      if (shouldbethere):
        ustf.error(2,"file %s doesn't exist"%filename)
      
# ------------------------------------------------------------
def validateFile(xmltarget):
  ustf.message("Using J.Clark JAVA tools...")
  ustf.message("Validation *only*")
  trang.validate(CCCCC.utils.filepaths.CCCCC_topfile,xmltarget)
  
# ------------------------------------------------------------
def defaults():
   c=CCCCC.utils.filepaths
   ustf.message("""Default XML files used by C5
RelaxNG    (SIDS): %s
XSLT       (user): %s
Schematron (user): %s
"""%(c.CCCCC_topschema,c.CCCCC_topschemaxslt,c.CCCCC_topschematron))
   
# ------------------------------------------------------------
def usage():
   ustf.message("""cgns - CGNS compiler (http://www.cgns.org) - v%s

usage: cgns [options] <tree_description_file>

options:
-o <file> : output file name for CGNS binary generation
-x <file> : output file name for XML generation (with -c option)

-c        : file to read is CGNS binary (default is XML file)

-f        : follow links when used with -c option
-d        : display data when used with -c option (up to 500 elements)
-D <size> : display data when used with -c option (up to <size> elements)

-z        : perform semantic passes (i.e. schematron)
-i        : keep XML preprocessed file (use -t to get file name)
-y        : keep pyCGNS generated file (use -t to get file name)

-T        : give all default file paths
-p <file> : use XLST preprocessor file instead of installation file
-r <file> : use relaxNG schema arg file instead of installation file
-s <file> : use Schematron arg file instead of installation file
-U <tag>  : use XSLT,RelaxNG and Schematron found in <tag> installation dir
-J        : call Java tools

-h        : help
-t        : trace

Notes:
- In *all* cases, SIDS syntax and semantics are enforced
- The -U <tag> files are read first, then -r, -s and -p files. For each pass,
  only the last file declared is used.
  preprocessing file root should be "c5preprocessing.xsl"
  syntax file root should be "c5syntax.rng"
  semantic file root should be "c5semantic.sch"
"""%CCCCC.__vid__)

# ------------------------------------------------------------
def go(fromimport=0):
   # return 0  if OK
   # return -1 if FAIL
   ustf.leave(fromimport)
   optkeylist="r:s:o:htp:izcx:fdyJTU:D:"
   pp=st=cg=fl=dt=jj=gpy=0
   relaxNGschema=None
   schematronSyntRules=None
   schematronSemRules=None
   outputfile=None
   preprocessor=None
   xmlfile=None
   readtagfiles=0
   arsz=500 # max array size to display
   try:
     optlist, val = getopt.getopt(sys.argv[1:],optkeylist,["help"])
   except getopt.GetoptError:
       usage()
       ustf.c5exit()
   try:
     for opt in optlist:
       #MODIFIE gestion de l'aide
       if (opt[0] == "-h" or opt[0] == "--help"):
           usage()
           ustf.c5exit()
       if (opt[0] == "-t"): ustf.trace()
       if (opt[0] == "-T"):
           defaults()
           ustf.c5exit()
       if (opt[0] == "-U"):
          readtagfiles=1
          tagdir=opt[1]
       if (opt[0] == "-y"): gpy=1
       if (opt[0] == "-f"): fl=1
       if (opt[0] == "-d"): dt=1
       if (opt[0] == "-D"):
           dt=1
           arsz=string.atoi(opt[1])
       if (opt[0] == "-i"): pp=1
       if (opt[0] == "-z"): st=1
       if (opt[0] == "-c"): cg=1
       if (opt[0] == "-J"): jj=1
       if (opt[0] == "-x"):
          xmlfile=opt[1]
          testFile(xmlfile)
       if (opt[0] == "-p"):
          preprocessor=opt[1]
          testFile(preprocessor,1)
       if (opt[0] == "-r"):
          relaxNGschema=opt[1]
          testFile(relaxNGschema,1)
       if (opt[0] == "-s"):
          schematronSemRules=opt[1]
          testFile(schematronSemRules,1)
       if (opt[0] == "-o"):
          outputfile=opt[1]
          testFile(outputfile)
     if not val:
         usage()
         ustf.c5exit()
   except ValueError, IndexError:
       usage()
       ustf.c5exit()
   ustf.message("CGNS compiler - v%s"%CCCCC.__vid__)
   if (not preprocessor and readtagfiles):
     preprocessor=readTagDir(tagdir,0)
   if (not relaxNGschema and readtagfiles):
     relaxNGschema=readTagDir(tagdir,1)
   if (not schematronSemRules and readtagfiles):
     schematronSemRules=readTagDir(tagdir,2)
   for filename in val:
     testFile(filename,1)
     filenametmp="%s.xslpp"%filename
     filenameT=filename
     if (cg):
       filenametmp2="%s.xml"%filename
       if (xmlfile): filenametmp2=xmlfile
       p_generateXML(filename,filenametmp2,fl,dt,arsz)
       filenameT=filenametmp2
     p_preprocessor(preprocessor,filenameT,filenametmp)
     if jj:
       validateFile(filenametmp)
     else:
       if (relaxNGschema):
         r=p_syntax(None,filenametmp,filename)
         if (r): ustf.message(r)
       r=p_syntax(relaxNGschema,filenametmp,filename)
       if (r): ustf.message(r)
       if (st):
         if (schematronSemRules):
           r=p_semantics(None,filenametmp)
           if (r): ustf.message(r)
         r=p_semantics(schematronSemRules,filenametmp)
         if (r): ustf.message(r)
         if (outputfile): p_generateHDF(filename,outputfile,fl,gpy)
     if (not pp): os.remove(filenametmp)
     if (cg and (not xmlfile)): os.remove(filenametmp2)

   # Memory debug specific
   libxml2.relaxNGCleanupTypes()
   libxml2.cleanupParser()
   #if libxml2.debugMemory(1) != 0:
   #    ustf.ttt("Memory leak %d bytes" % (libxml2.debugMemory(1)))
   #    libxml2.dumpMemory()
   global goreturnstatus
   return goreturnstatus

# ------------------------------------------------------------
if (__name__ == "__main__"):
  sys.exit(go())
  
