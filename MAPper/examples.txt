.. -------------------------------------------------------------------------
.. pyCGNS - CFD General Notation System - 
.. See license.txt file in the root directory of this Python module source  
.. -------------------------------------------------------------------------

.. _mapexamples:

MAP Examples
++++++++++++

The *CGNS.MAP* provides the user with the two functions ``load`` and ``save``,
these are direct mapping of 
the `CHLone <http://chlone.sourceforge.net/pythonCHLone.html#pythonchlone>`_ 
functions.
The actual actions these functions are performing heavily depends on the
arguments you pass to these functions, the ``load`` takes a *CGNS/HDF5* tree
and returns at least a *CGNS/Python* tree, while the ``save`` takes a
*CGNS/Python* tree and writes (modifies) a *CGNS/HDF5* tree.
Rather than listing all options, we suggest your try to figure out how to
use these functions reading the examples.

All the examples are assuming the following imports::

  import CGNS.MAP              
  import CGNS.PAT.cgnsutils    as CGU
  import CGNS.PAT.cgnskeywords as CGK
  import CGNS.PAT.cgnslib      as CGL

  import numpy as NPY

Complete load of a *CGNS/HDF5* file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The translation of a *CGNS/HDF5* file into a *CGNS/Python* tree is
performed with the simple line::

  (tree,links,paths)=CGNS.MAP.load("mesh.cgns")

If the ``testfile.cgns`` has no link the ``links`` and ``paths`` are
empty lists and ``tree`` contains the *CGNS/Python* tree.
The file name extension is not required, if the file doesn't exist
or if it is not a *CGNS/HDF5* file exceptions are raised::

  >>> T=CGNS.MAP.load('a.hdf')
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "pyCHLone.pyx", line 137, in CHLone.load (pyCHLone.c:2130)
  CHLone.CHLoneException: (900, 'No such file [a.hdf]')

  >>> T=CGNS.MAP.load('cgnscheck.pdf')
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "pyCHLone.pyx", line 151, in CHLone.load (pyCHLone.c:2398)
  CHLone.CHLoneException: (101, 'Target is not an HDF5 file [cgnscheck.pdf]')

You can see here the exception are coming from ``CHLone`` interface,
but as *CGNS.MAP* wraps *CHLone* you can also catch them as a *CGNS.MAP*
error::

  >>> try:
  ...   T=CGNS.MAP.load('cgnscheck.pdf')
  ... except CGNS.MAP.error, e:
  ...   print e
  ... 
  (101, 'Target is not an HDF5 file [cgnscheck.pdf]')

And if you write your own function, this leads to::

  def myload(filename):
    try:
      T=CGNS.MAP.load('cgnscheck.pdf')[0]
    except CGNS.MAP.error, e:
      T=None
    return T

In this latter example, we are forgetting ``links`` and ``paths``.

Complete save of a *CGNS/Python* tree
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now you have a *CGNS/Python* tree of your own, use the ``save`` 
to write the contents in a *CGNS/HDF5* file::

 CGNS.MAP.save("solution.hdf", tree)

Again, the file extension is not significant. You can save your file with 
the name you want as far as the file system is happy with it::

  CGNS.MAP.save('../solution.cgns',T)
  CGNS.MAP.save('RESULT',T)
  CGNS.MAP.save('solution.doc',T)

Of course, all these files are *HDF5* files, and you may have problem
with tools is you play with file names. Then we strongly suggest you
stay with usual file extensions such as ``cgns`` or ``hdf``.

If the file exist or if your file system doesn't want you to write
for any reason, you have an exception.

.. code-block:: python

   >>> T=CGNS.MAP.load('r.hdf')[0]
   >>> CGNS.MAP.save('r.hdf',T)
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
     File "pyCHLone.pyx", line 159, in CHLone.save (pyCHLone.c:2718)
   CHLone.CHLoneException: (901, 'File already exists [r.hdf]')

   >>> CGNS.MAP.save('tmp/solution.cgns',T)
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
     File "pyCHLone.pyx", line 169, in CHLone.save (pyCHLone.c:2918)
   CHLone.CHLoneException: (104, 'Cannot create new file [tmp/solution.cgns]')


Load of a *CGNS/HDF* file skeletton
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One of the big advantage of *CGNS* is to provide a complete and consistent
tree in data. Then you often want to parse it to get some information about
its structure or about a particuliar data. You do not want to load all
cooridnates and solution arrays, you just want the targetted information.
The *CGNS.MAP* load allows you to filter your target in the *CGNS/HDF5* file.

In this first exemaple we load only the zone layout of the tree. You want 
to distribute your zones on a cluster processors and you need to now the number
of zones and their sizes::

  T=CGNS.MAP.load('z.hdf',depth=3)

The ``depth`` argument tells *CGNS.MAP* to stop loading at level 3, which is
the ``Zone_t`` level; The first level is the root of the tree (``CGNSTree_t``)
then you have the base level (``CGNSBase_t``) and the zones.

Note you have all nodes at level 3, not only the zones. You need to
select the zones::

  zlist=CGU.getAllNodesByTypeSet(T[0],['Zone_t'])

In the case you have several ``CGNSBase_t`` you may want to filter
a specific base, use the ``subtree`` to tell to ``load`` to select only
the nodes with the given prefix, all together this leads to the following
lines.

.. code-block:: python

   >>> T=CGNS.MAP.load('z.hdf',subtree='/Base_1',depth=3)
   >>> print CGU.getAllPaths(T[0])
   ['/Base_1', '/Base_1/About', '/Base_1/Zone_0001', '/Base_1/Zone_0002']
   >>> zlist=CGU.getAllNodesByTypeSet(T[0],['Zone_t'])

Load of a *CGNS/HDF* file skeletton without data
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The previous example actually reads all the data of the *CGNS/HDF5* file,
its stops parsing the tree but every node is retrieved with its associated
array. Now we would like to find out the coordinates names, the node names
of the children of ``GridCoordinates_t``, but we do not want to load a
probably large amount of data. We use the ``madata`` threshold parameter,
all data above this size is returned as a *no-data* node::

 T=CGNS.MAP.load('mesh.hdf',maxdata=20,flags=CGNS.MAP.S2P_NODATA)

The ``CGNS.MAP.S2P_NODATA`` is required, without it the ``maxdata`` is
ignored. Here all the *CGNS/HDF5* tree is retrieved but nodes with a
data array with more than 20 entries is set as an ``MT`` (*empty*) node.
We can still parse the node names::

 >>> g=CGU.getNodeByPath(T[0],'/Mesh/Zone-004/GridCoordinates')
 ['GridCoordinates', None, [['CoordinateX', None, [], 'DataArray_t'], 
 ['CoordinateY', None, [], 'DataArray_t'], 
 ['CoordinateZ', None, [], 'DataArray_t']], 'GridCoordinates_t']

You should **not** save this tree, because you would overwrite the
coordinates nodes with empty arrays.

When you use the ``S2P_NODATA`` flag your result tree may contain ``MT``
nodes that actually have no data in the *CGNS/HDF5* file or node arrays that
have been ignored because of the ``maxdata`` threshold. The third entry
in the ``load`` return tuple is the ``paths``, it contains the paths of the
nodes that were ignored::

  >>> T=CGNS.MAP.load('mesh.hdf',maxdata=20,flags=CGNS.MAP.S2P_NODATA)
  >>> print T[2]
  [('/Mesh/Zone-004/GridCoordinates/CoordinateX',1),
   ('/Mesh/Zone-004/GridCoordinates/CoordinateY',1)
   ('/Mesh/Zone-004/GridCoordinates/CoordinateZ',1)]

The ``1`` associated with the path is the integer value corresponding to
the ``NODATA`` flag, it is useless at this time.

Load a tree without links
~~~~~~~~~~~~~~~~~~~~~~~~~

*to add: example with trunctated tree*

Save a tree with links
~~~~~~~~~~~~~~~~~~~~~~

*to add: example with recursive tree save per link*

Update a sub-tree
~~~~~~~~~~~~~~~~~

You have an existing *CGNS/Python* tree and you want to update a single node
from a *CGNS/HDF5* file, you do not want to load the complete file again or
even overwrite some modifications i nthe tree you have in memory. The
``updatedict`` argument of the ``load`` contains the actual *CGNS/Python*
nodes you want to update with respect to the associated path you give.

For example, you have a *CGNS/Python* tree with three coordinate nodes
you want to update, because you know some data has changed on the disk.
First you add an entry in ``updatedict`` with the target path as key,
then you set the value of this dictionary entry as the already existing
node you want to update. Be sure to set the node, *not the array* which
is the second entry in the node list::

  >>> T1=CGNS.MAP.load("mesh.cgns")
  >>> mydict={}
  >>> nodepath='/Mesh/Zone-001/GridCoordinates/CoordinateZ'
  >>> mydict[path]=CGU.getValueByPath(T1,nodepath)
  >>> T2=CGNS.MAP.load("mesh.cgns",updatedict=mydict)

The returned ``T2`` tree in the second ``load`` is a completely new one 
except the ``/Mesh/Zone-001/GridCoordinates/CoordinateZ`` node which is
now updated and shared by both ``T1`` and ``T2``.

If you want to load only this node and nothing else, use the ``subtree``
argument::

  >>> T1=CGNS.MAP.load("mesh.cgns")
  >>> mydict={}
  >>> nodepath='/Mesh/Zone-001/GridCoordinates/CoordinateZ'
  >>> mydict[path]=CGU.getValueByPath(T1,nodepath)
  >>> T2=CGNS.MAP.load("mesh.cgns",subtree=nodepath,updatedict=mydict)

Again you have updated the node in ``T1``, but you don't really need
the sub-tree you retrieve in ``T2``, which is a small copy of the nodes
along the path you give as argument.
To get rid of it, you forget the reference to the output, Python would
garbage by itself the unused data::

  >>> T1=CGNS.MAP.load("mesh.cgns")
  >>> mydict={}
  >>> nodepath='/Mesh/Zone-001/GridCoordinates/CoordinateZ'
  >>> mydict[path]=CGU.getValueByPath(T1,nodepath)
  >>> CGNS.MAP.load("mesh.cgns",subtree=nodepath,updatedict=mydict)

You are done, the node is updated into ``T1``.

Some usual issues
~~~~~~~~~~~~~~~~~

*to do: add here users\' usual mistakes*


