.. -------------------------------------------------------------------------
.. pyCGNS - CFD General Notation System - 
.. See license.txt file in the root directory of this Python module source  
.. -------------------------------------------------------------------------

.. _mapexamples:

MAP Examples
++++++++++++

The *CGNS.MAP* provides the user with the two functions ``load`` and ``save``.
The actual actions these functions are performing heavily depends on the
arguments you pass to these functions, the ``load`` takes a CGNS/HDF5 tree
and returns at least a CGNS/Python tree, while the ``save`` takes a
CGNS/Python tree and writes (modifies) a CGNS/HDF5 tree.
Rather than listing all options, we suggest your try to figure out how to
use these functions reading the examples.

All the examples are assuming the following imports::

  import CGNS.MAP
  import CGNS.PAT.cgnsutils    as CGU
  import CGNS.PAT.cgnskeywords as CGK
  import CGNS.PAT.cgnslib      as CGL

  import numpy as NPY

Complete load of a *CGNS/HDF* file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The translation of a CNS/HDF5 file into a CGNS/Python tree is
performed with the simple line::

  (tree,links)=CGNS.MAP.load("testfile.cgns")

.. code-block:: python
   :emphasize-lines: 3,5

   (tree,links)=CGNS.MAP.load("001Disk.hdf",CGNS.MAP.S2P_DEFAULT|)

   print tree


To be more precise, you can add the *depth*, the *path* and the *linkpath* of the file. In our case, the *depth* is worth 0 and the 
string's *path* is '' because we want to load entirely the tree. Here, the *linkpath* is an empty list because this file has'nt *links*.
As we are located in the same directory as the file, we don't owe necessarily write the *path*.

::

 import CGNS.MAP 

 (tree,links)=CGNS.MAP.load("001Disk.hdf", CGNS.MAP.S2P_DEFAULT,0, '', [], None)

 print tree

Complete save of a *CGNS/Python* tree
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To save a *CGNS/Python* tree, you have to use the *save* function which takes a CGNS/Python tree and writes the contents in a CGNS/HDF5 
file.
As the previous case, it's necessary to specify the file's name and its flags.   


::

 import CGNS.MAP

 status=CGNS.MAP.save("filename.hdf", tree, links, CGNS.MAP.S2P_DEFAULT)

Load of a *CGNS/HDF* file skeletton
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
You want to parse a GCNS/Python tree without the actual data (numpy arrays).
This is usefull when you want to find out specific nodes before actually
load them::

  flags=CGNS.MAP.S2P_DEFAULT|CGNS.MAP.S2P_NODATA
  (tree,lk)=CGNS.MAP.load("data/T0.cgns",flags,0,None,[],None)

  # find all zones
  zlist=CGU.getAllNodesByTypeList2([CGK.Zone_ts],tree)

In this example, we can also set the *depth* to 3 instead of 0. Then
the parse would stop at the zone level.
If you set *depth* to 0 there is no depth limit, 
a level of 1 means only `CGNSTree_t`,
a level of 2 means `CGNSLibraryVersion_t`, `CGNSBase_t` and so on...

In order to load the skeletton of a *CGNS/HDF* file, we use the *load* function with the *S2P_NODATA* flag. This flag acts by removing
all the data contained in the tree.

::

 import CGNS.MAP

 flags=CGNS.MAP.S2P_DEFAULT|CGNS.MAP.S2P_NODATA

 (tree,link)=CGNS.MAP.load("001Disk.hdf", flags, 0, '', [], None)

 print tree


Update a sub-tree
~~~~~~~~~~~~~~~~~

An existing CGNS/Python tree is read again from a file. The *update*
dictionnary declares the nodes you want to update instead of creating
new ones::

  updict={}
  path='/Disk/zone1/GridCoordinates/CoordinateZ'
  updict[path]=CGU.getValueByPath(tree,path)
  path='/Disk/zone2/GridCoordinates/CoordinateX'
  updict[path]=CGU.getValueByPath(tree,path)

  (tree,lk)=CGNS.MAP.load("data/T0.cgns",CGNS.MAP.S2P_DEFAULT,0,None,[],updict)

Then, we modify the data contained in the node whose the label is
'fluid' by replacing 'ideal' instead of 'perfect'.

 >>> tree[2][1][2][1][2][5]
 ['fluid',array(['I','d','e','a','l'],dtype='|S1'),[],'DataArray_t']

 >>> import numpy
 >>> tree[2][1][2][1][2][5][1]=numpy.array(tuple('parfait'),'|S1')

 >>> tree[2][1][2][1][2][5]
 ['fluid',array(['p','a','r','f','a','i','t'],dtype='|S1'),[],'DataArray_t']

Copy a part of a tree
~~~~~~~~~~~~~~~~~~~~~

To copy only a part of a tree, you have to use the *load* function by
mentioning the *path* which defines the start node of the load. In our
example, we load only the node whose label is 'fluid' because this
node has no children and the nodes '.SOLVER#Compute' and 'Disk' which
are parents of the node 'fluid'.

 import CGNS.MAP

 path='/Disk/.Solver#Compute/fluid'
 (tree,links)=CGNS.MAP.load("001Disk.hdf",CGNS.MAP.S2P_DEFAULT,0,path,[],None)

 >>> print tree

 ['CGNSTree', None, [['Disk', array([3, 3], dtype=int32), [['.Solver#Compute', None, 
 [['fluid', array(['I', 'd', 'e', 'a', 'l'], dtype='|S1'), [], 'DataArray_t']], 
 'UserDefinedData_t']], 'CGNSBase_t']], 'CGNSTree_t']


Copy and merge links
~~~~~~~~~~~~~~~~~~~~

In order to extract the *links*, you have to specify the path where are situated the other files which are linked to our file in a list.
For example, we are looking for the link files which are in the directory 'liens'.

Some usual issues
~~~~~~~~~~~~~~~~~

Your load leads to an empty tree::

 >>>import CGNS.MAP
 >>>(tree,links)=CGNS.MAP.load("./T0.cgns",CGNS.MAP.S2P_FOLLOWLINKS)
 >>>tree
 ['CGNSTree', None, None, 'CGNSTree_t']

 import CGNS.MAP

your file is an ADF file, not an HDF5 file.
 (tree, links)=CGNS.MAP.load("./liens/3element_airfoll_msh_cfd.hdf", CGNS.MAP.S2P_DEFAULT,0,'',['./liens/'],None)

 print links


