# CFD General Notation System - CGNS XML tools
# ONERA/DSNA - poinot@onera.fr - henaux@onera.fr
# pyCCCCC - $Id: match.py 40 2005-11-21 13:51:14Z  $ 
# 
# See file COPYING in the root directory of this Python module source 
# tree for license information.
# 
from numarray import *
from string  import *
from CGNS    import *

import CCCCC

import xml.dom.minidom as XmlDom
from xml.dom.NodeFilter import NodeFilter
from xml.dom            import Node

import sys
import re

# global feature set
#import numarray.arrayprint as ap
#ap.summary_off()

# not used below
floatsep=re.compile(r'([0-9.])[^0-9.Ee+1\]]+') # simpler ?
listsep1=re.compile(r'\]')
listsep2=re.compile(r'\],\]') 

#
# This is an "outputter" for CGNS SIDS XML representation as
# arbitrary defined into the Sift tool. In other words, the ouput obtained
# can be validated by Sift using the cgns.dtd defined in this pyCGNS Package.
#
dtd1path="/tools/dp/py-2.3/share/CGNS/cgns.dtd"
dtd2path="/tools/dp/py-2.3/share/CGNS/cgns-strings.dtd"

xmlheader2="""<?xml version="1.0"?>
<!DOCTYPE CGNS-Tree-t [
<!ENTITY %% cgns.tree    SYSTEM "%s">
<!ENTITY %% cgns.strings SYSTEM "%s">
%%cgns.tree;
%%cgns.strings;
]>
<CGNS-Tree-t CGNSLibraryVersion="%s">
"""

xmlheader="""<!-- 
pyCCCCC - v%s - see http://elsa.onera.fr/CGNS/releases
Generated by cgns tool from [%s] date [%s]
-->
<CGNSTree CGNSLibraryVersion="%.1f">
"""

xmlfooter="""
</CGNSTree>
"""

(tINTEGER,tSTRING,tARRAY,tFLOAT)=range(4)

enumElementType_t=("Null","UserDefined","NODE","BAR_2","BAR_3","TRI_3","TRI_6","QUAD_4","QUAD_8","QUAD_9","TETRA_4","TETRA_10","PYRA_5","PYRA_14","PENTA_6","PENTA_15","PENTA_18","HEXA_8","HEXA_20","HEXA_27","MIXED","NGON_n")

# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------
class NodeTranslator:
  def __init__(self,ar,out,db=None):
    self._arrays=ar   # force arrays if value set to 1 
    self._out=out
    self._base=0
    self._zone=0    
    self.__context=[]
    self.__db=db
    self._stack={}
    self._env=[]
    
  # ------------------------------------------------------------
  def __del__(self):
    pass
  
  def footer(self):
    self._out.write(xmlfooter)

  def header(self,filename,date,libversion):
    self._libversion=libversion
#    self._out.write(xmlheader%(dtd1path,dtd2path,self._libversion))
    self._out.write(xmlheader%(CCCCC.__vid__,filename,date,self._libversion))

  # ------------------------------------------------------------
  def printArray(self,s,a,decay,forcearray=0):
    # --- HARD CODED SIZE HERE

    # two scenarios
    # - you can force array print by calling printArray with forcearray==1
    # - you use -d option to force ALL arrays to be printed
    #
    localforcearray=forcearray 
    if (self._arrays):
      localforcearray=1
    maxsize=80
    if not s: return
    if (a.typecode() == UInt8): # string
      # bizarre thing with uninitialized char arrays
      # we have data after the \0, but we want the actual
      # array, not a "print-like" one. Thus we force the
      # \0 and replace them with @ (any other idea ?)
      # Morevoer, some dimensions can be 32x1 instead of 1x32 !
      # then we falt before substitution
      sar=a.tostring()
      sar=sar.replace("&", "&amp;")
      sar=sar.replace(">", "&gt;")
      sar=sar.replace("<", "&lt;")
      a=array(fromstring(sar,UInt8))
      if (localforcearray):
        shp=a.shape
        b=a.flat
        for n in range(len(b)):
          if not (b[n]): b[n]=ord('@')
        a=reshape(b,shp)
        for n in a.tostring():
          self._out.write(n)
    else:
      if (localforcearray and
          ((self._arrays==-1) or (len(a.flat)<self._arrays))
         ):
        ds=array2string(a,separator=', ')
        self._out.write('%s\012'%ds)
      else:
        datafile="NONE"
        self._out.write('<!-- Data -->\n')

  # ------------------------------------------------------------
  def p(self,decay,s=""):
    self._out.write(decay*' ')
    if s: self._out.write(s)
    else: self._out.write('\012')
    # --- actual write to CGNS file
    if self.__db:
      db=self.__db
      eval(s)
      if (db.error[0]):
        print '#Error %d [%s]'%(db.error[0],db.error[1])

  # ------------------------------------------------------------
  def labelcall(self,db,nodeinfo,decay,tag=''):
    # select action w.r.t. a given label/type
    # use the label string dictionnary to call the function
    # with the same name if it exist
    # This indirection is not necessary, but using this we can skip
    # unknown node (what about subtrees ?)
    lab=nam=None
    try:
      lab=nodeinfo['label']
      nam=nodeinfo['name']
      apply(NodeTranslator.__dict__[LabelString[nodeinfo['label']]+tag],
            [self,db,nodeinfo,decay])
    except KeyError:
      # deal with "special cases"
      #if ((lab == '"int[1+...+IndexDimension]"')
      #    and (nam == "DiffusionModel")):
      #   apply(NodeTranslator.__dict__["DiffusionModel_t"+tag],
      #         [self,db,nodeinfo,decay])
      #elif ((lab == '"int[IndexDimension]"') and (nam == "InwardNormalIndex")):
      #   apply(NodeTranslator.__dict__["InwardNormalIndex_t"+tag],
      #         [self,db,nodeinfo,decay])
      #elif ((lab == '"int[IndexDimension]"') and (nam == "Transform")):
      #   apply(NodeTranslator.__dict__["Transform_t"+tag],
      #         [self,db,nodeinfo,decay])
      #elif ((lab == '"int"')
      #      and (nam == "EquationDimension")):
      #   apply(NodeTranslator.__dict__["EquationDimension_t"+tag],
      #         [self,db,nodeinfo,decay])
      #elif ((lab == 'IndexRange_t')
      #      and (nam == "PointRange")):
      #   apply(NodeTranslator.__dict__["PointRange_t"+tag],
      #         [self,db,nodeinfo,decay])
      #elif ((lab == 'IndexRange_t')
      #      and (nam == "PointRangeDonor")):
      #   apply(NodeTranslator.__dict__["PointRangeDonor_t"+tag],
      #         [self,db,nodeinfo,decay])
      #elif (lab == 'IndexRange_t'):
      #   apply(NodeTranslator.__dict__["IndexRangeX_t"+tag],
      #         [self,db,nodeinfo,decay])
      #else:
      self.p(decay,"""<!-- skip [%s] [%s] -->\n"""%(lab,nam))

  # TAGS
  #
  # <typeName>    generate XML open AST node
  # <typeName>_   generate XML close AST node
  #
  # <typeName>g   generate pyCGNS open AST node
  # <typeName>g_  generate pyCGNS close AST node
  #
  def tagcall(self,type,tree,tag='g'):
    nm=re.sub("-","_",type)
    try:
      apply(NodeTranslator.__dict__[nm+tag],[self,tree])
    except KeyError:
      #self.p(0,"""<!-- skip [%s] -->\n"""%(type))
      pass

  def close(self,db,nodeinfo,decay):
    # we add a trailnig underscore to indicate this is the close function
    self.labelcall(db,nodeinfo,decay,'_')

  def open(self,db,nodeinfo,decay):
    self.labelcall(db,nodeinfo,decay)      

  # ------------------------------------------------------------
  def getMLLtype(self,type):
    if (type == 'R8'): return 'RealDouble'
    if (type == 'R4'): return 'RealSingle'
    if (type == 'I4'): return 'Integer'
    if (type == 'C1'): return 'Character'

  # ------------------------------------------------------------
  def getDataFromType(self,type,data):
    if (type == 'RealDouble'): return """ %s,'d' """  %string.strip(data)
    if (type == 'RealSingle'): return """ %s,'f' """  %string.strip(data)
    if (type == 'Integer')   : return """ %s,'i' """  %string.strip(data)
    if (type == 'Character') : return """ "%s",'c' """%string.strip(data)

  # ------------------------------------------------------------
  def cgnsEnum(self,db,nodeinfo,decay,etype,ename,noclose=0):
    self.p(decay)
    s="""<%s_t Name="%s" """%(etype,ename)
    ar=db.read_all_data(nodeinfo['id'])
    s+=""" cgnsdata="%s" """%ar.tostring()
    if (noclose): s+=" >  \n"
    else:         s+=" /> \n"
    self.p(decay,s)
      
  # ------------------------------------------------------------
  def getAndDrop(self,tree,typename):
    # find a first-level-child with type name, return it but DROP it
    # because we do not want ot parse it again...
    for cn in tree.getChildrenList(None):
      if (cn.nodeName == typename):
        return cn.parentNode.removeChild(cn)
    return None
    
  # ------------------------------------------------------------
  def clearContext(self):
      self.__context=[]
  def addContext(self,node):
      #print "PUSH CONTEXT ",node
      self.__context+=[node] # node is (node-type, index)
      self.addEnv(node)
  def popContext(self):
      if (not self.__context): return
      #print "POP CONTEXT ",self.__context[-1]
      self.__context=self.__context[:-1]
  def getContext(self,node):
    max=len(self.__context)
    for idx in range(max):
      if (self.__context[max-idx-1][0]==node):
        return self.__context[max-idx-1]
      return -1
  def gotoContext(self):
      # Jump to current context, for cg_goto Nodes
      s ="""# --- Goto (jump to parent node)\n"""
      s+="""db.goto(b%s,["""%(self._base)
      for ncx in self.__context:
        s+="""('%s',%s),"""%(ncx[0],ncx[1])
      s+="""])\n"""
      s+="""checkError("goto")\n\n"""
      self.p(0,s)

  # ------------------------------------------------------------
  # Env is like Context but I'm not sure to understand the use of Context
  def clearEnv(self):
    del self._env[len(self._env)-1]
  def addEnv(self,node):
    self._env.append(node)
  def getEnv(self):
    return self._env[len(self._env)-1]
  
  # ------------------------------------------------------------
  def _getNodeAsAttribute(self,db,id,name,tp=tSTRING):
    db.set_error_state(0)
    #print "+++ name ds getNodeAsAttr : ",name
    cid=db.get_node_id(id,name)
    s=''
    #print "+++ ERROR : ",db.error," --> ",db.error_message(db.error)
    if (db.error == -1):
      ar=db.read_all_data(cid)
      #print "+++ ",ar
      if ((tp == tINTEGER) or (tp == tFLOAT)):  v=str(ar[0])
      elif (tp == tARRAY): v=str(ar.tolist())
      elif (tp == tSTRING): v=ar.tostring()
      else: v=str(ar)
      #print "+++ ",v
      s+=""" %s="%s" """%(name,v)
    return s
      
  # ------------------------------------------------------------
  def _InwardNormalIndex(self,db,id):
    return self._getNodeAsAttribute(db,id,'InwardNormalIndex',tARRAY)
      
  # ------------------------------------------------------------
  def _DataClass(self,db,id):
    return self._getNodeAsAttribute(db,id,'DataClass')

  # ------------------------------------------------------------
  def _EquationDimension(self,db,id):
    return self._getNodeAsAttribute(db,id,'EquationDimension',tINTEGER)
      
  # ------------------------------------------------------------
  def _GridLocation(self,db,id):
    return self._getNodeAsAttribute(db,id,'GridLocation')
    
  # ------------------------------------------------------------
  def _Transform(self,db,id):
    return self._getNodeAsAttribute(db,id,'Transform',tARRAY)
      
  # ------------------------------------------------------------
  def _Ordinal(self,db,id):
    return self._getNodeAsAttribute(db,id,'Ordinal',tINTEGER)

  # ------------------------------------------------------------
  def _SimulationType(self,db,id):
     return self._getNodeAsAttribute(db,id,'SimulationType')
      
  # ------------------------------------------------------------
  def _FamilyName(self,db,id):
     return self._getNodeAsAttribute(db,id,'FamilyName')

  # ------------------------------------------------------------
  def _DiffusionModel(self,db,id):
     return self._getNodeAsAttribute(db,id,'DiffusionModel',tARRAY)

  # ------------------------------------------------------------
  # ADF Root
  # ------------------------------------------------------------
  def CGNSLibraryVersion_t(self,db,nodeinfo,decay):
    pass
      
  def CGNSLibraryVersion_t_(self,db,nodeinfo,decay):
    pass
  
  # ------------------------------------------------------------
  # Building-Block Structure Definitions
  # ------------------------------------------------------------
  
  def DataClass_t(self,db,nodeinfo,decay):
      pass
      
  def DataClass_t_(self,db,nodeinfo,decay):
      pass
    
  # ------------------------------------------------------------
  def Descriptor_t(self,db,nodeinfo,decay):
      # Special cases in there
      n=nodeinfo['name']
      if (n == "ReferenceStateDescription"):
        self.p(decay,"""<ReferenceStateDescription_t Name="%s" >\n"""%n)
      elif (n == "NormDescriptor"):
        self.p(decay,"""<NormDescriptor_t Name="%s" >\n"""%n)
      else:          
        self.p(decay,"""<Descriptor_t Name="%s" >\n"""%nodeinfo['name'])
      ar=db.read_all_data(nodeinfo['id'])
      
      # we should translate special chars
      sar=ar.tostring()
      sar=sar.replace("&", "&amp;")
      sar=sar.replace(">", "&gt;")
      sar=sar.replace("<", "&lt;")
      self.printArray(-1,array(fromstring(sar,UInt8)),0,1)
      
  def Descriptor_t_(self,db,nodeinfo,decay):
      n=nodeinfo['name']
      if (n == "ReferenceStateDescription"):
        self.p(decay,"""</ReferenceStateDescription_t>\n""")
      elif (n == "NormDescriptor"):
        self.p(decay,"""</NormDescriptor_t>\n""")
      else:          
        self.p(decay,"""</Descriptor_t>\n""")

  # ------------------------------------------------------------
  def DimensionalUnits_t(self,db,nodeinfo,decay):
      s="""<DimensionalUnits_t Name="%s" """%nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      br=reshape(ar,(5,32))
      s+=""" MassUnits="%s" """       %strip(br[0].tostring())
      s+=""" LengthUnits="%s" """     %strip(br[1].tostring())
      s+=""" TimeUnits="%s" """       %strip(br[2].tostring())
      s+=""" TemperatureUnits="%s" """%strip(br[3].tostring())
      s+=""" AngleUnits="%s" """      %strip(br[4].tostring())
      s+=" />\n"
      self.p(decay,s)
      
  def DimensionalUnits_t_(self,db,nodeinfo,decay):
      pass #self.p(decay,"""</DimensionalUnits_t>\n""")

  # ------------------------------------------------------------
  def DimensionalExponents_t(self,db,nodeinfo,decay):
      s="""<DimensionalExponents_t Name="%s" """%nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" MassExponent="%s" """%ar[0]
      s+=""" LengthExponent="%s" """%ar[1]
      s+=""" TimeExponent="%s" """%ar[2]
      s+=""" TemperatureExponent="%s" """%ar[3]
      s+=""" AngleExponent="%s" """%ar[4]
      s+=" />\n"
      self.p(decay,s)
      
  def DimensionalExponents_t_(self,db,nodeinfo,decay):
      pass

  # ------------------------------------------------------------
  def GridLocation_t(self,db,nodeinfo,decay):
      pass
      
  def GridLocation_t_(self,db,nodeinfo,decay):
      pass

    # ------------------------------------------------------------
  def IndexArray_t(self,db,nodeinfo,decay):
      dim=nodeinfo['dimensions']
      #print nodeinfo
      dt=self.getMLLtype(nodeinfo['datatype'])
      n=nodeinfo['name']
      if (n == "PointList"):
        s="""<PointList_t Name="%s" """%n
      elif (n == "PointListDonor"):
        s="""<PointListDonor_t Name="%s" """%n
      elif (n == "CellListDonor"):
        s="""<CellListDonor_t Name="%s" """%n
      elif (n == "InwardNormalList"):
        s="""<InwardNormalList_t Name="%s" """%n   
      else:
        s="""<IndexArray_t Name="%s" """%n
      s+=""" ArraySize="%s" """%dim[1]
      s+=""" IndexDimension="%s" """%self._stack['IndexDimension']
      s+=""" DataType="%s" """%dt
      s+=">\n"
      self.p(decay,s)
      ar=db.read_all_data(nodeinfo['id'])
      self.printArray(-1,ar,0)
      
  def IndexArray_t_(self,db,nodeinfo,decay):
      n=nodeinfo['name']
      if (n == "PointList"):
        s="""</PointList_t>\n"""
      elif (n == "PointListDonor"):
        s="""</PointListDonor_t>\n"""
      elif (n == "CellListDonor"):
        s="""</CellListDonor_t>\n"""
      elif (n == "InwardNormalList"):
        s="""</InwardNormalList_t>\n"""
      else:
        s="""</IndexArray_t>\n"""
      self.p(decay,s)

  # ------------------------------------------------------------
  # #OLD (there's a trailing X here to make the function call fail with the
  # #label. See labelcall)
  def IndexRange_t(self,db,nodeinfo,decay):
      n=nodeinfo['name']
      if (n == "PointRange"):
        s="""<PointRange_t Name="%s" """%n
      elif (n == "PointRangeDonor"):
        s="""<PointRangeDonor_t Name="%s" """%n
      else:
        s="""<IndexRange_t Name="%s" """%n
      s+=""" IndexDimension="%s" """%self._stack['IndexDimension']
      ar=db.read_all_data(nodeinfo['id'])
      if (n == "ElementRange"):
        # in that case, keep Begin/End with dimension 1
        s+=""" Begin="[%s]" """%str(ar[0])
        s+=""" End="[%s]" """%str(ar[1])
      else:
        s+=""" Begin="%s" """%str(ar[0].tolist())
        s+=""" End="%s" """%str(ar[1].tolist())
      s+="/>\n"
      self.p(decay,s)
      
  def IndexRange_t_(self,db,nodeinfo,decay):
      pass
 
  # ------------------------------------------------------------
  def Rind_t(self,db,nodeinfo,decay):
      s="""<Rind_t Name="%s" """%(nodeinfo['name']) # should be Rind
      s+=""" IndexDimension="%s" """%self._stack['IndexDimension']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" RindPlanes="%s" """%str(ar.tolist())
      s+=" />\n"
      # I dont't know if rindPlanes has Data??? #
      self.p(decay,s)
      
  def Rind_t_(self,db,nodeinfo,decay):
      pass # self.p(decay,"""</Rind_t>\n""")

  # ------------------------------------------------------------
  # Data-Array Structures Definitions
  # ------------------------------------------------------------
  # I should make something more clear, maybe put that into printArray
  def DataArray_t(self,db,nodeinfo,decay):
      dim=nodeinfo['dimensions']
      dt=self.getMLLtype(nodeinfo['datatype'])
      n=nodeinfo['name']
      nodeEnv=self.getEnv()
      if (n == "ElementConnectivity"):
        s="""<ElementConnectivity_t Name="%s" """%n
      elif (n == "InterpolantsDonor"):
        s="""<InterpolantsDonor_t Name="%s" """%n
      elif (n == "ParentData"):
        s="""<ParentData_t Name="%s" """%n
      elif (n == "TimeValues"):
        s="""<TimeValues_t Name="%s" """%n
      elif (n == "IterationValues"):
        s="""<IterationValues_t Name="%s" """%n
      elif (n == "NumberOfZones"):
        s="""<NumberOfZones_t Name="%s" """%n
      elif (n == "NumberOfFamilies"):
        s="""<NumberOfFamilies_t Name="%s" """%n
      elif (n == "ZonePointers"):
        s="""<ZonePointers_t Name="%s" """%n
      elif (n == "FamilyPointers"):
        s="""<FamilyPointers_t Name="%s" """%n
      elif (n == "AxisymmetryReferencePoint_t"):
        s="""<AxisymmetryReferencePoint_t Name="%s" """%n
      elif (n == "AxisymmetryAxisVector_t"):
        s="""<AxisymmetryAxisVector_t Name="%s" """%n
      elif (n == "AxisymmetryAngle_t"):
        s="""<AxisymmetryAxisAngle__t Name="%s" """%n
      elif (n == "CoordinatesNames_t"):
        s="""<CoordinatesNames__t Name="%s" """%n
      elif (n == "RotationCenter_t"):
        s="""<RotationCenter__t Name="%s" """%n
      elif (n == "RotationRateVector_t"):
        s="""<RotationRateVector_t Name="%s" """%n
      elif (n == "RotationAngle_t"):
        s="""<RotationAngle_t Name="%s" """%n
      elif (n == "Translation_t"):
        s="""<Translation_t Name="%s" """%n
      elif (n == "SurfaceArea_t"):
        s="""<SurfaceArea_t Name="%s" """%n
      elif (n == "RegionName_t"):
        s="""<RegionName_t Name="%s" """%n
      elif (n == "GravityVector_t"):
        s="""<GravityVector_t Name="%s" """%n  
      elif (nodeinfo['label']=='BCData_t'):
        if (dim[0]==1):
          s="""<DataGlobal_t Name="%s" """%n
        else:
          s="""<DataLocal_t Name="%s" """%n
      else:
        s="""<DataArray_t Name="%s" """%n
        
      s+=self._DataClass(db,nodeinfo['id'])
      s+=""" DataType="%s" """%dt
      s+=""" Dimension="%s" """%len(dim)
      s+=""" DimensionValues="%s" > \n"""%str(list(dim))
      self.p(decay,s)
      ar=db.read_all_data(nodeinfo['id'])
      self.printArray(-1,ar,1)
      
  def DataArray_t_(self,db,nodeinfo,decay):
      nodeEnv=self.getEnv()
      dim=nodeinfo['dimensions']
      #I think that it's more logical to read data in the open tag (above)
      #ar=db.read_all_data(nodeinfo['id'])
      #self.printArray(-1,ar,0)
      n=nodeinfo['name']
      if (n == "ElementConnectivity"):
        s="""</ElementConnectivity_t>\n"""
      elif (n == "ParentData"):
        s="""</ParentData_t>\n"""
      elif (n == "InterpolantsDonor"):
        s="""</InterpolantsDonor_t>\n"""
      elif (n == "TimeValues"):
        s="""</TimeValues_t>\n"""
      elif (n == "IterationValues"):
        s="""</IterationValues_t>\n"""
      elif (n == "NumberOfZones"):
        s="""</NumberOfZones_t>\n"""
      elif (n == "NumberOfFamilies"):
        s="""</NumberOfFamilies_t>\n"""
      elif (n == "ZonePointers"):
        s="""</ZonePointers_t>\n"""
      elif (n == "FamilyPointers"):
        s="""</FamilyPointers_t>\n"""
      elif (n == "AxisymmetryReferencePoint_t"):
        s="""</AxisymmetryReferencePoint_t>\n"""
      elif (n == "AxisymmetryAxisVector_t"):
        s="""</AxisymmetryAxisVector_t>\n"""
      elif (n == "AxisymmetryAngle_t"):
        s="""</AxisymmetryAxisAngle__t>\n"""
      elif (n == "CoordinatesNames_t"):
        s="""</CoordinatesNames__t>\n"""
      elif (n == "RotationCenter_t"):
        s="""</RotationCenter__t>\n"""
      elif (n == "RotationRateVector_t"):
        s="""</RotationRateVector_t>\n"""
      elif (n == "RotationAngle_t"):
        s="""</RotationAngle_t>\n"""
      elif (n == "Translation_t"):
        s="""</Translation_t>\n"""
      elif (n == "SurfaceArea_t"):
        s="""</SurfaceArea_t>\n"""
      elif (n == "RegionName_t"):
        s="""</RegionName_t>\n"""
      elif (nodeinfo['label']=='BCData_t'):
        if (dim[0]==1):
          s="""</DataGlobal_t>\n"""
        else:
          s="""</DataLocal_t>\n"""
      else:
        s="""</DataArray_t>\n"""
      self.p(decay,s)

  def DataArray_tg(self,tree):
      self.gotoContext()
      localVariable=tree.nextId()
      data=tree.getPCData()
      s ="""# --- DataArray_t\n"""
      if (not data):
        # creates a zeroed array (for skeletton purposes)
        tsize="(%s)"%tree.getAll()['DimensionValues'][1:-1]
        s+="""v%s=numarray.zeros(%s)\n"""%\
            (localVariable,\
             self.getDataFromType(tree.getAll()['DataType'],tsize))
      else:
        s+="""v%s=numarray.array(%s)\n"""%\
            (localVariable,\
             self.getDataFromType(tree.getAll()['DataType'],data))
      s+="""db.arraywrite('%s'"""%tree.getName()
      s+=""",%(DataType)s"""%tree.getAll()
      s+=""",%(Dimension)s"""%tree.getAll()
      s+=""",%s"""%str(tuple(eval(tree.getAll()['DimensionValues'])))
      s+=""",v%s)\n"""%localVariable
      s+="""checkError("DataArray")\n\n"""
      self.p(0,s)

  # ------------------------------------------------------------
  def DataConversion_t(self,db,nodeinfo,decay):
      s="""<DataConversion_t Name="%s" """ %nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" ConversionScale="%s" """%ar[0]
      s+=""" ConversionOffset="%s" """%ar[1]
      s+=" />\n"
      self.p(decay,s)
      
  def DataConversion_t_(self,db,nodeinfo,decay):
      pass
    
  # ------------------------------------------------------------
  # Hierarchical Structures
  # ------------------------------------------------------------
  def CGNSBase_t(self,db,nodeinfo,decay):
      s="""<CGNSBase_t Name="%s" """%nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" PhysicalDimension="%d" CellDimension="%d" """%(ar[0],ar[1])
      self.addContext((CGNSBase_t,1)) # base id is ???
      self._stack['PhysicalDimension']=ar[0]
      self._stack['CellDimension']=ar[1]
      # Optional attributes
      s+=self._SimulationType(db,nodeinfo['id'])
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def CGNSBase_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</CGNSBase_t>\n""")
      
  def CGNSBase_tg(self,tree):
      bid=tree.nextId()
      s ="""# --- CGNSBase_t\n"""
      s+="""b%s=db.basewrite('%s'"""%(bid,tree.getName())
      s+=""",%(PhysicalDimension)s,"""%tree.getAll()
      s+="""%(CellDimension)s)\n"""%tree.getAll()
      s+="""checkError("CGNSBase")\n\n"""
      self._base=bid
      self.p(0,s)
      
  # ------------------------------------------------------------
  def SimulationType_t(self,db,nodeinfo,decay):
      pass

  def SimulationType_t_(self,db,nodeinfo,decay):
      pass
    
  # ------------------------------------------------------------
  def Zone_t(self,db,nodeinfo,decay):
      s="""<Zone_t Name="%s" """%nodeinfo['name']
      d0=self._stack['PhysicalDimension']
      d1=self._stack['CellDimension']
      s+=""" PhysicalDimension="%d" CellDimension="%d" """%(d0,d1)
      # check wether we are in Unstructured (IndexDimension==1) or Structured
      # ZoneType_t is mandatory, we do a "forward" call to this node, which
      # will be skipped when reached as a "parsed" node
      cid=db.get_node_id(nodeinfo['id'],'ZoneType')
      ar=db.read_all_data(cid)
      s+=""" ZoneType="%s" """%strip(ar.tostring())
      dtx=db.read_all_data(nodeinfo['id'])
      if (ar[0] == ord('U')):
        self._stack['IndexDimension']=1
        dtt=[dtx[0],dtx[1],dtx[2]]
      else:
        self._stack['IndexDimension']=self._stack['CellDimension']
        dtt=dtx
      s+=""" VertexSize="%s" """%str(dtt[0].tolist())
      s+=""" CellSize="%s" """%str(dtt[1].tolist())
      s+=""" VertexSizeBoundary="%s" """%str(dtt[2].tolist())
      self._stack['VertexSize']=str(dtt[0].tolist())
      self._stack['CellSize']=str(dtt[1].tolist())
      s+=self._DataClass(db,nodeinfo['id'])
      s+=self._FamilyName(db,nodeinfo['id'])
      s+=self._Ordinal(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def Zone_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</Zone_t>\n""")

  def Zone_tg(self,tree):
      zid=tree.nextId()
      sz =eval(str(tree.getAll()['VertexSize']))
      sz+=eval(str(tree.getAll()['CellSize']))
      sz+=eval(str(tree.getAll()['VertexSizeBoundary']))
      s ="""# --- Zone_t\n"""
      s+="""z%s=db.zonewrite(b%s,'%s'"""%(zid,self._base,tree.getName())
      s+=""",%s,"%s")\n"""%(tuple(sz),tree.getAll()['ZoneType'])
      s+="""checkError("Zone")\n\n"""
      self.addContext((Zone_t,"z%s"%zid))
      self.p(0,s)
      
  def Zone_tg_(self,tree):
      self.popContext()

  # ------------------------------------------------------------
  # Grid Coordinates, Elements, FlowSolutions
  # ------------------------------------------------------------
  def GridCoordinates_t(self,db,nodeinfo,decay):
      s="""<GridCoordinates_t Name="%s" """%nodeinfo['name']
      s+=""" IndexDimension="%s" """%self._stack['IndexDimension']
      s+=""" VertexSize="%s" """%self._stack['VertexSize']
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def GridCoordinates_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</GridCoordinates_t>\n""")

  def GridCoordinates_tg(self,tree):
    zid=self.getContext(Zone_t)[1]
    gid=tree.nextId()
    # --- Writes grid, not gridcoordinates -> delaguates to DataArray
    s ="""# --- GridCoordinates_t\n"""
    s+="""g%s=db.gridwrite(b%s,%s,"""%(gid,self._base,zid)
    s+=""""%s")\n"""%tree.getName()
    s+="""checkError("GridCoordinates")\n\n"""
    self.addContext((GridCoordinates_t,"g%s"%gid))
    self.p(0,s)        

  def GridCoordinates_tg_(self,tree):
      self.popContext()

  # ------------------------------------------------------------
  def Elements_t(self,db,nodeinfo,decay):
      s="""<Elements_t Name="%s" """%nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" ElementType="%s" """%enumElementType_t[ar[0]]
      if len(ar)>1:
        s+=""" ElementSizeBoundary="%s" """%str(ar[1])
      s+=">\n"
      self.p(decay,s)
      
  def Elements_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</Elements_t>\n""")

  # ------------------------------------------------------------
  def Axisymmetry_t(self,db,nodeinfo,decay):
      s="""<Axisymmetry_t Name="%s" """%nodeinfo['name']
      s+=self._DataClass(db,nodeinfo['id'])
      s+=">\n"
      self.p(decay,s)
      
  def Axisymmetry_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</Axisymmetry_t>\n""")

  # ------------------------------------------------------------
  def RotatingCoordinates_t(self,db,nodeinfo,decay):
      s="""<RotatingCoordinates_t Name="%s" """%nodeinfo['name']
      s+=self._DataClass(db,nodeinfo['id'])
      s+=">\n"
      self.p(decay,s)
      
  def _t_(self,db,nodeinfo,decay):
      self.p(decay,"""</RotatingCoordinates_t>\n""")     
      
  # ------------------------------------------------------------
  def FlowSolution_t(self,db,nodeinfo,decay):
      s="""<FlowSolution_t Name="%s" """%nodeinfo['name']
      s+=""" IndexDimension="%s" """%self._stack['IndexDimension']
      s+=""" VertexSize="%s" """%self._stack['VertexSize']
      s+=""" CellSize="%s" """%self._stack['CellSize']
      s+=self._GridLocation(db,nodeinfo['id'])
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      if nodeinfo['dimensions']: 
        ar=db.read_all_data(nodeinfo['id'])
        self.printArray(-1,ar,0)
      
  def FlowSolution_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</FlowSolution_t>\n""")
      
  # ------------------------------------------------------------
  # Multizone Interface Connectivity
  # ------------------------------------------------------------
  def ZoneGridConnectivity_t(self,db,nodeinfo,decay):
      s="""<ZoneGridConnectivity_t Name="%s" """%nodeinfo['name']
      s+=""" IndexDimension="%s" """%self._stack['IndexDimension']
      s+=""" CellDimension="%s" """%self._stack['CellDimension']
      s+=" >\n"
      self.p(decay,s)
      
  def ZoneGridConnectivity_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</ZoneGridConnectivity_t>\n""")

  def ZoneGridConnectivity_tg(self,tree):
      pass
      
  # ------------------------------------------------------------
  def GridConnectivity1to1_t(self,db,nodeinfo,decay):
      s ="""<GridConnectivity1to1_t Name="%s" """%nodeinfo['name']
      s+=""" IndexDimension="%s" """%self._stack['IndexDimension']
      s+=self._Transform(db,nodeinfo['id'])
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" ZoneDonorName="%s">\n"""%ar.tostring()
      s+=self._Ordinal(db,nodeinfo['id'])
      self.p(decay,s)
      
  def GridConnectivity1to1_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</GridConnectivity1to1_t>\n""")

  def GridConnectivity1to1_tg(self,tree):
      # loop on all nodes
      s ="db.one2onewrite(%d,%d"%(self._base,self._zone)
      s+=",'%s'"%(tree.getName())
      s+=",'%s'"%(tree.getData())
      nlist=tree.getTag("IndexRange_t")
      for n in nlist:
        dd=tree.getPCData(n)
        ar=tuple(array(eval(dd.strip())).flat.tolist())
        nm=tree.getName(n)
        if (nm == "PointRange"):      rr=ar
        if (nm == "PointRangeDonor"): rd=ar
      s+=",%s,%s"%(rr,rd)
      n=tree.getTag("Transform_t")[0] # only one node
      tt=tree.getPCData(n)
      ar=tuple(array(eval(tt.strip())).flat.tolist())
      s+=",%s)\n"%(ar,) # don't remove trailing , which makes it a tuple
      self.p(0,s)

  # ------------------------------------------------------------
  def GridConnectivity_t(self,db,nodeinfo,decay):
      s="""<GridConnectivity_t Name="%s" """%nodeinfo['name']
      s+=""" IndexDimension="%s" """%self._stack['IndexDimension']
      s+=""" CellDimension="%s" """%self._stack['CellDimension']
      id_c=db.get_node_id(nodeinfo['id'],'GridConnectivityType')
      if nodeinfo['id'] != id_c:
        type=strip((db.read_all_data(id_c)).tostring())
      else:
        type="Overset"
      s+=""" GridConnectivityType="%s" """%type
      grdLoc=self._GridLocation(db,nodeinfo['id'])
      #if grdLoc=='':
      #  grdLoc=""" GridLocation="Vertex" """
      s+=grdLoc  
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" ZoneDonorName="%s" """%strip(ar.tostring())
      s+=self._Ordinal(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def GridConnectivity_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</GridConnectivity_t>\n""")

  def GridConnectivity_tg(self,tree):
      pass

  # ------------------------------------------------------------  
  def GridConnectivityProperty_t(self,db,nodeinfo,decay):
      s="""<GridConnectivityProperty_t Name="%s" """%nodeinfo['name']
      s+=" >\n"
      self.p(decay,s)
      
  def GridConnectivityProperty_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</GridConnectivityProperty_t>\n""")
      
  # ------------------------------------------------------------    
  def Periodic_t(self,db,nodeinfo,decay):
      s="""<Periodic_t Name="%s" """%nodeinfo['name']
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def Periodic_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</Periodic_t>\n""")
    
  # ------------------------------------------------------------
  def OversetHoles_t(self,db,nodeinfo,decay):
      s="""<OversetHoles_t Name="%s" """%nodeinfo['name']
      grdLoc=self._GridLocation(db,nodeinfo['id'])
      #if grdLoc=='':
      #  grdLoc=""" GridLocation="Vertex" """
      s+=grdLoc  
      s+=" >\n"
      self.p(decay,s)
      
  def OversetHoles_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</GridConnectivity_t>\n""")

  def OversetHoles_tg(self,tree):
      pass
    
  # ------------------------------------------------------------
  # Boundary Conditions
  # ------------------------------------------------------------
  def ZoneBC_t(self,db,nodeinfo,decay):
      s="""<ZoneBC_t Name="%s" """%nodeinfo['name']
      s+=""" IndexDimension="%s" """%self._stack['IndexDimension']
      s+=""" PhysicalDimension="%s" """%self._stack['IndexDimension']
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def ZoneBC_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</ZoneBC_t>\n""")
      
  #def ZoneBC_tg(self,tree):
  #    zbid=tree.nextId()
  #    
  #def ZoneBC_tg_(self,tree):
  #    self.popContext()

  # ------------------------------------------------------------
  def BC_t(self,db,nodeinfo,decay):
      lst_c=db.children_names(nodeinfo['id'])
      self._stack['ListLength']=0
      for c in lst_c:
        if c=="PointList":
          dim_c=db.get_dimension_values(db.get_node_id(nodeinfo['id'],'PointList'))
          self._stack['ListLength']= dim_c[1]
        elif c=="PointRange":
          ar=db.read_all_data(db.get_node_id(nodeinfo['id'],'PointRange'))
          arp=ar[1]-ar[0]+1
          self._stack['ListLength']=product(arp)
      s="""<BC_t Name="%s" """%nodeinfo['name']
      s+=""" IndexDimension="%s" """%self._stack['IndexDimension']
      s+=""" PhysicalDimension="%s" """%self._stack['IndexDimension']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" BCType="%s" """%strip(ar.tostring())
      s+=self._DataClass(db,nodeinfo['id'])
      s+=self._Ordinal(db,nodeinfo['id'])
      s+=self._FamilyName(db,nodeinfo['id'])
      s+=self._GridLocation(db,nodeinfo['id'])
      s+=self._InwardNormalIndex(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def BC_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</BC_t>\n""")

  def BC_tg(self,tree):
      wid=tree.nextId()
      s ="""# --- BC_t\n"""
      s+="""w%s=db.bcwrite(b%s,%s"""%(wid,self._base,self.getContext(Zone_t)[1])
      s+=""",'%s','%s'"""%(tree.getName(),tree.getAll()['BCType'])
      # find PointRange/PointList delete node !
      pt=self.getAndDrop(tree,'PointRange_t')
      if (not pt):
        pt=self.getAndDrop(tree,'PointList_t')
        s+=""",'%s'"""%(tree.getName(pt)) # should be PointList
        # get PCdata
      else:
        plist="[%s,%s]"%(tree.getAll(pt)['Begin'],tree.getAll(pt)['End'])
        s+=""",'%s',%s)\n"""%(tree.getName(pt),plist) # should be PointRange
      s+="""checkError("BC")\n\n"""
      self.addContext((ZoneBC_t,1))
      self.addContext((BC_t,"w%s"%wid))
      self.p(0,s)        
      
  def BC_tg_(self,tree):
      self.popContext() # BC_t
      self.popContext() # ZoneBC_t
      
  # ------------------------------------------------------------
  def InwardNormalIndex_t(self,db,nodeinfo,decay):
    pass
      
  def InwardNormalIndex_t_(self,db,nodeinfo,decay):
    pass
  
  # ------------------------------------------------------------
  def BCDataSet_t(self,db,nodeinfo,decay):
      s="""<BCDataSet_t Name="%s" """%nodeinfo['name']
      s+=""" ListLength="%s" """%self._stack['ListLength']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" BCTypeSimple="%s" """%strip(ar.tostring())
      s+=self._GridLocation(db,nodeinfo['id'])
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def BCDataSet_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</BCDataSet_t>\n""")

  # ------------------------------------------------------------
  def BCData_t(self,db,nodeinfo,decay):
    # Special cases in there
      n=nodeinfo['name']
      if (n == "NeumannData"):
        s="""<NeumannData_t Name="%s" \n"""%n
      elif (n == "DirichletData"):
        s="""<DirichletData_t Name="%s" \n"""%n
      else:          
        s="""<BCData_t Name="%s" \n"""%n
      s+=""" ListLength="%s" """%self._stack['ListLength']
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  # ------------------------------------------------------------    
  def BCData_t_(self,db,nodeinfo,decay):
    # Special cases in there
      n=nodeinfo['name']
      if (n == "NeumannData"):
        s="""</NeumannData_t> \n"""
      elif (n == "DirichletData"):
        s="""</DirichletData_t>\n"""
      else:          
        s="""</BCData_t>\n"""
      self.p(decay,s)
      
  # ------------------------------------------------------------  
  def BCProperty_t(self,db,nodeinfo,decay):
      s="""<BCProperty_t Name="%s" """%nodeinfo['name']
      s+=" >\n"
      self.p(decay,s)
      
  def BCProperty_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</BCProperty_t>\n""")
      
  # ------------------------------------------------------------  
  def WallFunction_t(self,db,nodeinfo,decay):
      s="""<WallFunction_t Name="%s" """%nodeinfo['name']
      s+=" >\n"
      self.p(decay,s)
      
  def WallFunction_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</WallFunction_t>\n""")
      
  # ------------------------------------------------------------  
  def Area_t(self,db,nodeinfo,decay):
      s="""<Area_t Name="%s" """%nodeinfo['name']
      s+=" >\n"
      self.p(decay,s)
      
  def Area_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</Area_t>\n""")
      
  # ------------------------------------------------------------
  # Governing Flow Equations
  # ------------------------------------------------------------
  def FlowEquationSet_t(self,db,nodeinfo,decay):
      s="""<FlowEquationSet_t Name="%s" """%nodeinfo['name']
      d0=self._stack['CellDimension']
      s+=""" CellDimension="%d" """%d0
      s+=self._EquationDimension(db,nodeinfo['id'])
      s+=self._DataClass(db,nodeinfo['id'])
      s+=">\n"
      self.p(decay,s)
      
  def FlowEquationSet_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</FlowEquationSet_t>\n""")

  # ------------------------------------------------------------
  def GoverningEquations_t(self,db,nodeinfo,decay):
      s="""<GoverningEquations_t Name="%s" """%nodeinfo['name']
      d0=self._stack['CellDimension']
      s+=""" CellDimension="%d" """%d0
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" GoverningEquationsType="%s" """%strip(ar.tostring())
      s+=self._DiffusionModel(db,nodeinfo['id'])
      s+=">\n"
      self.p(decay,s)

  def GoverningEquations_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</GoverningEquations_t>\n""")

  # ------------------------------------------------------------
  def GasModel_t(self,db,nodeinfo,decay):
      s="""<GasModel_t Name="%s" """%nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" GasModelType="%s" """%strip(ar.tostring())
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def GasModel_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</GasModel_t>\n""")

  # ------------------------------------------------------------
  def ViscosityModel_t(self,db,nodeinfo,decay):
      s="""<ViscosityModel_t Name="%s" """%nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" ViscosityModelType="%s" """%strip(ar.tostring())
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      #self.cgnsEnum(db,nodeinfo,decay,"ViscosityModel","ViscosityModel",1)
      
  def ViscosityModel_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</ViscosityModel_t>\n""")
      
  # ------------------------------------------------------------
  def ThermalConductivityModel_t(self,db,nodeinfo,decay):
      s="""<ThermalConductivityModel_t Name="%s" """%nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" ThermalConductivityModelType="%s" """%strip(ar.tostring())
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)

  def ThermalConductivityModel_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</ThermalConductivityModel_t>\n""")

  # ------------------------------------------------------------
  def TurbulenceClosure_t(self,db,nodeinfo,decay):
      s="""<TurbulenceClosure_t Name="%s" """%nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" TurbulenceClosureType="%s" """%strip(ar.tostring())
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def TurbulenceClosure_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</TurbulenceClosure_t>\n""")

  # ------------------------------------------------------------
  def TurbulenceModel_t(self,db,nodeinfo,decay):
      s="""<TurbulenceModel_t Name="%s" """%nodeinfo['name']
      d0=self._stack['CellDimension']
      s+=""" CellDimension="%d" """%d0
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" TurbulenceModelType="%s" """%strip(ar.tostring())
      s+=self._DataClass(db,nodeinfo['id'])
      s+=self._DiffusionModel(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def TurbulenceModel_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</TurbulenceModel_t>\n""")
      
  # ------------------------------------------------------------
  def ThermalRelaxationModel_t(self,db,nodeinfo,decay):
      s="""<ThermalRelaxationModel_t Name="%s" """%nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" ThermalRelaxationModelType="%s" """%strip(ar.tostring())
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)

  def ThermalRelaxationModel_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</ThermalRelaxationModel_t>\n""")
  
  # ------------------------------------------------------------
  def ChemicalKineticsModel_t(self,db,nodeinfo,decay):
      s="""<ChemicalKineticsModel_t Name="%s" """%nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" ChemicalKineticsModelType="%s" """%strip(ar.tostring())
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def ChemicalKineticsModel_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</ChemicalKineticsModel_t>\n""")    

  # ------------------------------------------------------------
  # Time-Dependent Flow
  # ------------------------------------------------------------
  def BaseIterativeData_t(self,db,nodeinfo,decay):
      s="""<BaseIterativeData_t Name="%s" """%nodeinfo['name']
      s+=self._DataClass(db,nodeinfo['id'])
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" NumberOfSteps="%s" """%str(ar[0])
      self._stack['NumberOfSteps']=ar[0]
      s+=" >\n"
      self.p(decay,s)
      
  def BaseIterativeData_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</BaseIterativeData_t>\n""")

  # ------------------------------------------------------------
  def ZoneIterativeData_t(self,db,nodeinfo,decay):
      s="""<ZoneIterativeData_t Name="%s" """%nodeinfo['name']
      s+=""" NumberOfSteps="%d" """%self._stack['NumberOfSteps']
      s+=" >\n"
      self.p(decay,s)
      
  def ZoneIterativeData_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</ZoneIterativeData_t>\n""")

  # ------------------------------------------------------------
  def RigidGridMotion_t(self,db,nodeinfo,decay):
      s="""<RigidGridMotion_t Name="%s" """%nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" RigidGridMotionType="%s" """%strip(ar.tostring())
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def RigidGridMotion_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</RigidGridMotion_t>\n""")
      
  # ------------------------------------------------------------
  def ArbitraryGridMotion_t(self,db,nodeinfo,decay):
      s="""<ArbitraryGridMotion_t Name="%s" """%nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" IndexDimension="%s" """%self._stack['IndexDimension']
      s+=""" VertexSize="%s" """%self._stack['VertexSize']
      s+=""" CellSize="%s" """%self._stack['CellSize']
      s+=""" ArbitraryGridMotionType="%s" """%strip(ar.tostring())
      s+=self._GridLocation(db,nodeinfo['id'])
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def ArbitraryGridMotion_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</ArbitraryGridMotion_t>\n""")    
          
  # ------------------------------------------------------------
  # Miscellaneous Data Structures
  # ------------------------------------------------------------
  def ReferenceState_t(self,db,nodeinfo,decay):
      s="""<ReferenceState_t Name="%s" """%nodeinfo['name']
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def ReferenceState_tg(self,tree):
    self.gotoContext()
    s ="""# --- ReferenceState_t\n"""
    s+="""db.statewrite("No description")\n"""
    s+="""checkError("ReferenceState")\n\n"""
    self.addContext((ReferenceState_t,1))
    self.p(0,s)
      
  def ReferenceState_tg_(self,tree):
      self.popContext()

  # ------------------------------------------------------------
  def ConvergenceHistory_t(self,db,nodeinfo,decay):
      s="""<ConvergenceHistory_t Name="%s" """%nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      s+="""Iterations ="%s" """%str(ar[0])
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def ConvergenceHistory_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</ConvergenceHistory_t>\n""")
      
  # ------------------------------------------------------------
  def DiscreteData_t(self,db,nodeinfo,decay):
      s="""<DiscreteData_t Name="%s" """%nodeinfo['name']
      ar=db.read_all_data(nodeinfo['id'])
      s+=""" IndexDimension="%s" """%self._stack['IndexDimension']
      s+=""" VertexSize="%s" """%self._stack['VertexSize']
      s+=""" CellSize="%s" """%self._stack['CellSize']
      s+=self._GridLocation(db,nodeinfo['id'])
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def DiscreteData_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</DiscreteData_t>\n""")
      
  # ------------------------------------------------------------
  def IntegralData_t(self,db,nodeinfo,decay):
      s="""<IntegralData_t Name="%s" """%nodeinfo['name']
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def IntegralData_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</IntegralData_t>\n""")
      
  # ------------------------------------------------------------
  def Family_t(self,db,nodeinfo,decay):
      s="""<Family_t Name="%s" """%nodeinfo['name']
      cid=db.get_node_id(nodeinfo['id'],'FamilyBC')
      if (cid and (nodeinfo['datatype'] != 'MT')): # old version compatibility
        ar=db.read_all_data(cid)
        s+=""" FamilyBC ="%s" """%strip(ar.tostring())
      s+=self._Ordinal(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def Family_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</Family_t>\n""")

  # ------------------------------------------------------------
  def FamilyName_t(self,db,nodeinfo,decay):
      pass
           
  def FamilyName_t_(self,db,nodeinfo,decay):
      pass

  def FamilyName_tg(self,tree):
      self.gotoContext()
      nm=tree.getName()
      if (nm != "FamilyName"): dd=tree.getData()
      else:                    dd=tree.getName() # migration from v1.x
      s="""db.familynamewrite('%s')\n"""%nm
      self.p(0,s)
      
  # ------------------------------------------------------------
  def UserDefinedData_t(self,db,nodeinfo,decay):
      self.p(decay,"""<UserDefinedData_t Name="%s">\n"""%nodeinfo['name'])
      if nodeinfo['dimensions']: 
        ar=db.read_all_data(nodeinfo['id'])
        self.printArray(-1,ar,0)
      
  def UserDefinedData_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</UserDefinedData_t>\n""")
      
  def UserDefinedData_tg(self,tree):
    self.gotoContext()
    uid=tree.nextId()
    # we can only COUNT userdefs and then pray that the order is correct...
    self.addContext((UserDefinedData_t,"u%s"%uid))
    s ="""# --- UserDefinedData_t\n"""
    s+="""u%s=db.userdatawrite("%s")\n"""%(uid,tree.getName())
    s+="""checkError("UserDefinedData")\n\n"""
    self.p(0,s)

  def UserDefinedData_tg_(self,tree):
      self.popContext()
      
  # ------------------------------------------------------------
  def Gravity_t(self,db,nodeinfo,decay):
      s="""<Gravity_t Name="%s" """%nodeinfo['name']
      s+=self._DataClass(db,nodeinfo['id'])
      s+=" >\n"
      self.p(decay,s)
      
  def Gravity_t_(self,db,nodeinfo,decay):
      self.p(decay,"""</Gravity_t\n""")
      
  # ------------------------------------------------------------
  # Common Type
  # ------------------------------------------------------------

  def EquationDimension_t(self,db,nodeinfo,decay):
    pass
      
  def EquationDimension_t_(self,db,nodeinfo,decay):
    pass
  
  # ------------------------------------------------------------
  def Ordinal_t(self,db,nodeinfo,decay):
    pass
        
  def Ordinal_t_(self,db,nodeinfo,decay):
    pass

  # ------------------------------------------------------------
  #def Transform_t(self,db,nodeinfo,decay):
  #   pass
          
  #def Transform_t_(self,db,nodeinfo,decay):
  #  pass

  #def Transform_tg(self,tree):
  #  pass

  # ------------------------------------------------------------
  #def DiffusionModel_t(self,db,nodeinfo,decay):
  #  pass
      
  #def DiffusionModel_t_(self,db,nodeinfo,decay):
  #  pass

# ------------------------------------------------------------
# ------------------------------------------------------------
class TreeGenerator:
  def __init__(self,xmltree,output,mode,ofile):
    self.__tree=xmltree
    self.__re_empty=re.compile(r"^[\n\t ]*$")
    self.__nodestack=[]
    self.__mode=mode
    self.__count=0
    self.__ofilename=ofile
    if (self.__mode):
      self.__out=output # Write python commands file
      self.__db=None
    else:
      self.__db=output  # Write CGNS file straight
      self.__out=sys.stdout
    self.__level=0
  # ------------------------------------------------------------
  def at(self,attname):
    return (None, u'%s'%attname)
  # ------------------------------------------------------------
  def ky(self,key):
    return "%s"%key[1]
  # ------------------------------------------------------------
  def val(self,node,att):
    if node.hasAttribute(att):
      return node.getAttribute(att)
    return None
  # --------------------------------------------------
  def generate(self):
      self._cx=NodeTranslator(0,self.__out,self.__db)
      # parse tree
      # calls at opening node and closing node
      # call first node -> only one child: top of the tree
      self.header()
      self.__nodestack+=[self.getChildrenList(self.__tree)[-1:]]
      self.parseTree(self.getChildrenList(self.__tree)[-1:])
      self.footer()
  # --------------------------------------------------
  def getChildrenList(self,node):
    if (node): return node.childNodes
    return self.__nodestack[-1].childNodes
  # --------------------------------------------------
  def parseTree(self,cnodelist):
      self.__level+=1
      if (cnodelist == []):
        self.__level-=1
        return None
      for cnode in cnodelist:
        if (cnode.nodeName == XmlDom.Node.COMMENT_NODE):
          print "COMMENT"
        
        if (cnode.nodeName == XmlDom.Node.TEXT_NODE):
          print "TEXT"

        else:

          self.__nodestack+=[cnode]                        # push
          self._cx.tagcall(cnode.nodeName,self)            # open
          self.parseTree(self.getChildrenList(cnode))      # recurse
          self._cx.tagcall(cnode.nodeName,self,tag='g_')   # close
          self.__nodestack=self.__nodestack[:-1]           # pop
    
      self.__level-=1
  # --------------------------------------------------
  def getName(self,node=None):
    if (not node): node=self.__nodestack[-1]
    return self.val(node,'Name')
  # --------------------------------------------------
  def getData(self,node=None):
    if (not node): node=self.__nodestack[-1]
    return self.val(node,'cgnsdata')
  # --------------------------------------------------
  def getPCData(self,node=None):
    if (not node): node=self.__nodestack[-1]
    for child in node.childNodes:
      if (child.nodeType == Node.TEXT_NODE):
        # get text, eliminate stuff like \10,\13, tab, spaces...
        # get the first one anyway !
        tt=child.data
        if (tt and (not self.__re_empty.match(tt))): return child.data
      else:
        pass #print child
    return None
  # --------------------------------------------------
  def get(self,name,node=None):
    if (not node): node=self.__nodestack[-1]
    return self.val(node,name)
  # --------------------------------------------------
  def getAll(self,node=None):
    # return the whole dictionnary
    if (not node): node=self.__nodestack[-1]
    d={}
    for k in range(node.attributes.length):
      d[node.attributes.item(k).name]=node.attributes.item(k).value
    return d
  # --------------------------------------------------
  def getTag(self,tag):
    return self.__nodestack[-1].getElementsByTagName(tag)
  # --------------------------------------------------
  def nextId(self):
    s="%.4d"%self.__count
    self.__count+=1
    return s
  # --------------------------------------------------
  def header(self):
    s ="""#!/usr/bin/env python\n# pyC5/pyCGNS generated file\n"""
    s+="""#\nimport numarray\nfrom CGNS import *\n\n"""
    s+="""def checkError(s):\n"""
    s+="""  e=db.lasterror()\n"""
    s+="""  if (e[0]):\n"""
    s+="""    print "# error[%.3d]: %s"%e\n"""
    s+="""    print "# in        : %s"%s\n\n"""
    s+="""# --- pyCGNS Create\ndb=pyCGNS("%s",MODE_WRITE)\n"""\
        %(self.__ofilename)
    s+="""checkError("open %s")\n\n"""%(self.__ofilename)
    self.__out.write(s)
  # --------------------------------------------------
  def footer(self):
    s ="""# --- Close\ndb.close()\n# --- Last line\n"""
    
def generateFromFile(file,output,mode=0):
  xml_dom_object = XmlDom.parse(file)
  t=TreeGenerator(xml_dom_object,output,mode)
  t.generate()
  reader.releaseNode(xml_dom_object)
  
#def _t_(self,db,nodeinfo,decay):
#self.p(decay,"""</_t>\n""")


